"""
Malware Scanner for File Uploads
Advanced malware detection using signature-based and heuristic analysis
"""

import os
import re
import hashlib
import logging
from typing import Dict, List, Tuple, Optional
from django.core.exceptions import ValidationError
from django.conf import settings

# Security logger
security_logger = logging.getLogger('security')

class MalwareScanner:
    """
    Advanced malware scanner for uploaded files
    """
    
    # Known malware file hashes (MD5) - sample database
    MALWARE_HASHES = {
        # Example malware hashes (these are fake for demonstration)
        'e3b0c44298fc1c149afbf4c8996fb924': 'Generic.Trojan',
        '5d41402abc4b2a76b9719d911017c592': 'Test.Malware',
        # Add real malware hashes from threat intelligence feeds
    }
    
    # Suspicious file patterns
    SUSPICIOUS_PATTERNS = {
        'executable_headers': [
            b'MZ',  # PE executable
            b'\x7fELF',  # ELF executable
            b'\xfe\xed\xfa\xce',  # Mach-O 32-bit
            b'\xfe\xed\xfa\xcf',  # Mach-O 64-bit
            b'\xca\xfe\xba\xbe',  # Java class file
        ],
        
        'script_patterns': [
            rb'<script[^>]*>.*?</script>',
            rb'javascript:',
            rb'vbscript:',
            rb'data:text/html',
            rb'eval\s*\(',
            rb'exec\s*\(',
            rb'system\s*\(',
            rb'shell_exec\s*\(',
        ],
        
        'php_patterns': [
            rb'<\?php',
            rb'<\?=',
            rb'<\?\s',
            rb'eval\s*\(\s*base64_decode',
            rb'eval\s*\(\s*gzinflate',
            rb'eval\s*\(\s*str_rot13',
        ],
        
        'sql_injection_patterns': [
            rb'UNION\s+SELECT',
            rb'DROP\s+TABLE',
            rb'DELETE\s+FROM',
            rb'INSERT\s+INTO',
            rb'UPDATE\s+.*\s+SET',
            rb'--\s*$',
            rb'/\*.*?\*/',
        ],
        
        'command_injection_patterns': [
            rb';\s*rm\s+-rf',
            rb';\s*cat\s+/etc/passwd',
            rb';\s*wget\s+',
            rb';\s*curl\s+',
            rb'`[^`]*`',
            rb'\$\([^)]*\)',
        ],
        
        'archive_bombs': [
            rb'PK\x03\x04.*PK\x03\x04.*PK\x03\x04',  # Multiple ZIP headers
            rb'BZh[0-9]1AY&SY',  # BZIP2 bomb signature
            rb'\x1f\x8b\x08.*\x1f\x8b\x08',  # Multiple GZIP headers
        ],
        
        'polyglot_files': [
            rb'%PDF-.*<html',  # PDF with HTML
            rb'\xff\xd8\xff.*<script',  # JPEG with script
            rb'\x89PNG.*<\?php',  # PNG with PHP
        ],
    }
    
    # Entropy thresholds for detecting packed/encrypted content
    HIGH_ENTROPY_THRESHOLD = 7.5
    SUSPICIOUS_ENTROPY_THRESHOLD = 6.5
    
    def __init__(self):
        """Initialize the malware scanner"""
        self.scan_results = {}
    
    def scan_file(self, file_obj, filename: str) -> Dict[str, any]:
        """
        Comprehensive malware scan of uploaded file
        
        Args:
            file_obj: File object to scan
            filename: Original filename
            
        Returns:
            Dict with scan results
            
        Raises:
            ValidationError: If malware is detected
        """
        scan_result = {
            'filename': filename,
            'file_size': file_obj.size,
            'is_clean': True,
            'threats_detected': [],
            'warnings': [],
            'scan_details': {
                'hash_scan': False,
                'signature_scan': False,
                'heuristic_scan': False,
                'entropy_analysis': False,
            }
        }
        
        try:
            # Step 1: Hash-based detection
            self._hash_based_scan(file_obj, scan_result)
            
            # Step 2: Signature-based detection
            self._signature_based_scan(file_obj, scan_result)
            
            # Step 3: Heuristic analysis
            self._heuristic_analysis(file_obj, scan_result)
            
            # Step 4: Entropy analysis
            self._entropy_analysis(file_obj, scan_result)
            
            # Step 5: File structure analysis
            self._structure_analysis(file_obj, scan_result)
            
            # Final assessment
            if scan_result['threats_detected']:
                scan_result['is_clean'] = False
                threat_list = ', '.join(scan_result['threats_detected'])
                security_logger.error(
                    f"Malware detected in {filename}: {threat_list}"
                )
                raise ValidationError(
                    f"File contains malicious content: {threat_list}"
                )
            
            # Log clean scan
            security_logger.info(f"Malware scan clean: {filename}")
            
            return scan_result
            
        except ValidationError:
            raise
        except Exception as e:
            security_logger.error(f"Malware scan error for {filename}: {str(e)}")
            raise ValidationError(f"Error during malware scan: {str(e)}")
    
    def _hash_based_scan(self, file_obj, result: Dict):
        """Hash-based malware detection"""
        file_obj.seek(0)
        
        # Calculate MD5 hash
        md5_hash = hashlib.md5()
        for chunk in iter(lambda: file_obj.read(4096), b""):
            md5_hash.update(chunk)
        
        file_hash = md5_hash.hexdigest()
        file_obj.seek(0)
        
        # Check against known malware hashes
        if file_hash in self.MALWARE_HASHES:
            malware_name = self.MALWARE_HASHES[file_hash]
            result['threats_detected'].append(f"Known malware: {malware_name}")
        
        result['scan_details']['hash_scan'] = True
        result['file_hash'] = file_hash
    
    def _signature_based_scan(self, file_obj, result: Dict):
        """Signature-based malware detection"""
        file_obj.seek(0)
        
        # Read file content in chunks
        chunk_size = 8192
        content_buffer = b""
        
        while True:
            chunk = file_obj.read(chunk_size)
            if not chunk:
                break
            
            content_buffer += chunk
            
            # Keep buffer size manageable
            if len(content_buffer) > 1024 * 1024:  # 1MB buffer
                self._scan_buffer_for_patterns(content_buffer[:512*1024], result)
                content_buffer = content_buffer[512*1024:]
        
        # Scan remaining buffer
        if content_buffer:
            self._scan_buffer_for_patterns(content_buffer, result)
        
        file_obj.seek(0)
        result['scan_details']['signature_scan'] = True
    
    def _scan_buffer_for_patterns(self, buffer: bytes, result: Dict):
        """Scan buffer for malicious patterns"""
        for category, patterns in self.SUSPICIOUS_PATTERNS.items():
            for pattern in patterns:
                if isinstance(pattern, bytes):
                    if pattern in buffer:
                        result['threats_detected'].append(f"Suspicious pattern: {category}")
                        break
                else:  # regex pattern
                    if re.search(pattern, buffer, re.IGNORECASE | re.MULTILINE):
                        result['threats_detected'].append(f"Suspicious pattern: {category}")
                        break
    
    def _heuristic_analysis(self, file_obj, result: Dict):
        """Heuristic analysis for unknown threats"""
        file_obj.seek(0)
        content = file_obj.read(min(file_obj.size, 1024 * 1024))  # Read up to 1MB
        file_obj.seek(0)
        
        # Check for suspicious characteristics
        
        # 1. High ratio of non-printable characters
        printable_chars = sum(1 for c in content if 32 <= c <= 126)
        if len(content) > 0:
            printable_ratio = printable_chars / len(content)
            if printable_ratio < 0.1 and len(content) > 1000:
                result['warnings'].append("High ratio of non-printable characters")
        
        # 2. Suspicious string patterns
        suspicious_strings = [
            b'CreateProcess',
            b'VirtualAlloc',
            b'WriteProcessMemory',
            b'SetWindowsHookEx',
            b'RegCreateKey',
            b'RegSetValue',
            b'WinExec',
            b'ShellExecute',
            b'URLDownloadToFile',
            b'InternetOpen',
            b'HttpSendRequest',
        ]
        
        for sus_string in suspicious_strings:
            if sus_string in content:
                result['warnings'].append(f"Suspicious API call: {sus_string.decode('ascii', errors='ignore')}")
        
        # 3. Base64 encoded content (potential obfuscation)
        base64_pattern = rb'[A-Za-z0-9+/]{20,}={0,2}'
        base64_matches = re.findall(base64_pattern, content)
        if len(base64_matches) > 10:
            result['warnings'].append("Multiple base64 encoded strings detected")
        
        # 4. Hex encoded content
        hex_pattern = rb'(?:[0-9a-fA-F]{2}){20,}'
        hex_matches = re.findall(hex_pattern, content)
        if len(hex_matches) > 5:
            result['warnings'].append("Multiple hex encoded strings detected")
        
        result['scan_details']['heuristic_scan'] = True
    
    def _entropy_analysis(self, file_obj, result: Dict):
        """Analyze file entropy to detect packed/encrypted content"""
        file_obj.seek(0)
        
        # Calculate entropy for different sections of the file
        section_size = min(8192, file_obj.size // 4) if file_obj.size > 8192 else file_obj.size
        entropies = []
        
        for i in range(0, min(file_obj.size, 32768), section_size):
            file_obj.seek(i)
            section = file_obj.read(section_size)
            if section:
                entropy = self._calculate_entropy(section)
                entropies.append(entropy)
        
        if entropies:
            avg_entropy = sum(entropies) / len(entropies)
            max_entropy = max(entropies)
            
            if max_entropy > self.HIGH_ENTROPY_THRESHOLD:
                result['threats_detected'].append(f"Extremely high entropy detected: {max_entropy:.2f}")
            elif avg_entropy > self.SUSPICIOUS_ENTROPY_THRESHOLD:
                result['warnings'].append(f"Suspicious entropy level: {avg_entropy:.2f}")
        
        file_obj.seek(0)
        result['scan_details']['entropy_analysis'] = True
    
    def _calculate_entropy(self, data: bytes) -> float:
        """Calculate Shannon entropy of data"""
        if not data:
            return 0
        
        # Count byte frequencies
        byte_counts = [0] * 256
        for byte in data:
            byte_counts[byte] += 1
        
        # Calculate entropy
        entropy = 0
        data_len = len(data)
        for count in byte_counts:
            if count > 0:
                probability = count / data_len
                entropy -= probability * (probability.bit_length() - 1)
        
        return entropy
    
    def _structure_analysis(self, file_obj, result: Dict):
        """Analyze file structure for anomalies"""
        file_obj.seek(0)
        header = file_obj.read(1024)
        file_obj.seek(0)
        
        # Check for polyglot files (files that are valid in multiple formats)
        polyglot_indicators = [
            (b'%PDF-', b'<html'),  # PDF with HTML
            (b'\xff\xd8\xff', b'<script'),  # JPEG with script
            (b'\x89PNG', b'<?php'),  # PNG with PHP
            (b'GIF8', b'<script'),  # GIF with script
        ]
        
        for indicator1, indicator2 in polyglot_indicators:
            if indicator1 in header and indicator2 in header:
                result['threats_detected'].append("Polyglot file detected")
                break
        
        # Check for embedded files
        embedded_signatures = [
            b'%PDF-',  # Embedded PDF
            b'\xff\xd8\xff',  # Embedded JPEG
            b'\x89PNG',  # Embedded PNG
            b'PK\x03\x04',  # Embedded ZIP
        ]
        
        signature_count = 0
        for signature in embedded_signatures:
            if header.count(signature) > 1:
                signature_count += 1
        
        if signature_count > 1:
            result['warnings'].append("Multiple file signatures detected")
    
    def update_malware_database(self, new_hashes: Dict[str, str]):
        """
        Update malware hash database
        
        Args:
            new_hashes: Dict of hash -> malware_name mappings
        """
        self.MALWARE_HASHES.update(new_hashes)
        security_logger.info(f"Updated malware database with {len(new_hashes)} new hashes")
    
    def get_scan_statistics(self) -> Dict[str, int]:
        """Get scanning statistics"""
        return {
            'total_scans': len(self.scan_results),
            'clean_files': sum(1 for r in self.scan_results.values() if r['is_clean']),
            'infected_files': sum(1 for r in self.scan_results.values() if not r['is_clean']),
            'files_with_warnings': sum(1 for r in self.scan_results.values() if r['warnings']),
        }


# Global scanner instance
malware_scanner = MalwareScanner()


def scan_file_for_malware(file_obj, filename: str = None) -> Dict[str, any]:
    """
    Scan file for malware using the global scanner instance
    
    Args:
        file_obj: File object to scan
        filename: Optional filename
        
    Returns:
        Scan results dictionary
        
    Raises:
        ValidationError: If malware is detected
    """
    if not filename:
        filename = getattr(file_obj, 'name', 'unknown')
    
    return malware_scanner.scan_file(file_obj, filename)