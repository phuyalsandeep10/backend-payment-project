"""
Automated Vulnerability Scanner - Task 6.1.1

Comprehensive vulnerability scanning capabilities for static code analysis,
dependency scanning, and configuration assessment.
"""

import os
import re
import ast
import json
import subprocess
import hashlib
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass, asdict
from datetime import datetime
import tempfile


@dataclass
class Vulnerability:
    """Data structure for vulnerability findings"""
    id: str
    severity: str  # critical, high, medium, low, info
    category: str
    title: str
    description: str
    file_path: str
    line_number: int
    code_snippet: str
    recommendation: str
    cwe_id: Optional[str] = None
    confidence: str = "medium"  # high, medium, low
    references: List[str] = None
    
    def __post_init__(self):
        if self.references is None:
            self.references = []


class VulnerabilityScanner:
    """
    Automated vulnerability scanner for security assessment
    Task 6.1.1: Vulnerability scanning capabilities
    """
    
    def __init__(self, project_root: str):
        self.project_root = project_root
        self.vulnerabilities: List[Vulnerability] = []
        
        # Security patterns for static analysis
        self.security_patterns = {
            'sql_injection': {
                'patterns': [
                    r'cursor\.execute\s*\(\s*["\'].*%s.*["\'].*%',
                    r'cursor\.execute\s*\(\s*f["\'].*\{.*\}.*["\']',
                    r'\.raw\s*\(\s*["\'].*%s.*["\'].*%',
                    r'\.raw\s*\(\s*f["\'].*\{.*\}.*["\']',
                    r'execute\s*\(\s*["\'][^"\']*\+.*["\']',
                ],
                'severity': 'critical',
                'category': 'injection',
                'cwe': 'CWE-89'
            },
            'xss': {
                'patterns': [
                    r'\.innerHTML\s*=.*request\.GET',
                    r'\.innerHTML\s*=.*request\.POST',
                    r'HttpResponse\s*\(.*request\.GET.*\)',
                    r'HttpResponse\s*\(.*request\.POST.*\)',
                    r'render_to_string\s*\(.*\|safe',
                ],
                'severity': 'high',
                'category': 'xss',
                'cwe': 'CWE-79'
            },
            'csrf_missing': {
                'patterns': [
                    r'@csrf_exempt',
                    r'csrf_exempt\s*\(',
                ],
                'severity': 'medium',
                'category': 'csrf',
                'cwe': 'CWE-352'
            },
            'hardcoded_secrets': {
                'patterns': [
                    r'SECRET_KEY\s*=\s*["\'][^"\']{20,}["\']',
                    r'PASSWORD\s*=\s*["\'][^"\']+["\']',
                    r'API_KEY\s*=\s*["\'][^"\']+["\']',
                    r'TOKEN\s*=\s*["\'][^"\']{20,}["\']',
                    r'password\s*=\s*["\'][^"\']+["\']',
                ],
                'severity': 'high',
                'category': 'secrets',
                'cwe': 'CWE-798'
            },
            'weak_crypto': {
                'patterns': [
                    r'hashlib\.md5\s*\(',
                    r'hashlib\.sha1\s*\(',
                    r'Crypto\.Hash\.MD5',
                    r'Crypto\.Hash\.SHA1',
                    r'random\.random\s*\(',
                ],
                'severity': 'medium',
                'category': 'crypto',
                'cwe': 'CWE-327'
            },
            'path_traversal': {
                'patterns': [
                    r'open\s*\(\s*.*request\.GET.*\)',
                    r'open\s*\(\s*.*request\.POST.*\)',
                    r'os\.path\.join\s*\(.*request\.GET',
                    r'os\.path\.join\s*\(.*request\.POST',
                ],
                'severity': 'high',
                'category': 'path_traversal',
                'cwe': 'CWE-22'
            },
            'debug_enabled': {
                'patterns': [
                    r'DEBUG\s*=\s*True',
                    r'ALLOWED_HOSTS\s*=\s*\[\s*\]',
                    r'print\s*\(\s*.*password',
                    r'console\.log\s*\(\s*.*password',
                ],
                'severity': 'medium',
                'category': 'configuration',
                'cwe': 'CWE-489'
            },
            'unsafe_deserialization': {
                'patterns': [
                    r'pickle\.loads?\s*\(',
                    r'cPickle\.loads?\s*\(',
                    r'yaml\.load\s*\(',
                    r'eval\s*\(',
                    r'exec\s*\(',
                ],
                'severity': 'critical',
                'category': 'deserialization',
                'cwe': 'CWE-502'
            }
        }
        
        # File extensions to scan
        self.scan_extensions = {'.py', '.js', '.html', '.css', '.json', '.yaml', '.yml', '.xml'}
        
        # Directories to exclude from scanning
        self.exclude_dirs = {
            '__pycache__', '.git', 'node_modules', 'venv', 'env',
            '.pytest_cache', 'migrations', 'static', 'media'
        }
    
    def run_comprehensive_scan(self) -> Dict[str, Any]:
        """
        Run comprehensive vulnerability scan
        Task 6.1.1: Complete vulnerability scanning
        """
        
        print("üîç Starting Comprehensive Vulnerability Scan...")
        print(f"Scanning directory: {self.project_root}")
        print("=" * 60)
        
        # Static code analysis
        self._run_static_analysis()
        
        # Dependency vulnerability scan
        self._run_dependency_scan()
        
        # Configuration security scan
        self._run_configuration_scan()
        
        # File permission scan
        self._run_permission_scan()
        
        # Generate scan report
        return self._generate_scan_report()
    
    def _run_static_analysis(self):
        """Run static code analysis for vulnerability patterns"""
        print("üìù Running static code analysis...")
        
        scanned_files = 0
        
        for root, dirs, files in os.walk(self.project_root):
            # Skip excluded directories
            dirs[:] = [d for d in dirs if d not in self.exclude_dirs]
            
            for file in files:
                file_path = os.path.join(root, file)
                
                # Check file extension
                if not any(file.endswith(ext) for ext in self.scan_extensions):
                    continue
                
                try:
                    with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                        content = f.read()
                    
                    self._analyze_file_content(file_path, content)
                    scanned_files += 1
                    
                except Exception as e:
                    print(f"‚ö†Ô∏è  Error scanning {file_path}: {e}")
                    continue
        
        print(f"‚úÖ Static analysis completed. Scanned {scanned_files} files.")
    
    def _analyze_file_content(self, file_path: str, content: str):
        """Analyze file content for security vulnerabilities"""
        lines = content.split('\n')
        
        for pattern_name, pattern_info in self.security_patterns.items():
            for pattern in pattern_info['patterns']:
                for line_num, line in enumerate(lines, 1):
                    match = re.search(pattern, line)
                    if match:
                        vuln_id = self._generate_vulnerability_id(file_path, line_num, pattern_name)
                        
                        vulnerability = Vulnerability(
                            id=vuln_id,
                            severity=pattern_info['severity'],
                            category=pattern_info['category'],
                            title=self._get_vulnerability_title(pattern_name),
                            description=self._get_vulnerability_description(pattern_name),
                            file_path=os.path.relpath(file_path, self.project_root),
                            line_number=line_num,
                            code_snippet=line.strip(),
                            recommendation=self._get_vulnerability_recommendation(pattern_name),
                            cwe_id=pattern_info.get('cwe'),
                            confidence=self._assess_confidence(pattern_name, line)
                        )
                        
                        self.vulnerabilities.append(vulnerability)
    
    def _run_dependency_scan(self):
        """Scan dependencies for known vulnerabilities"""
        print("üì¶ Running dependency vulnerability scan...")
        
        # Check for requirements.txt
        requirements_files = [
            'requirements.txt',
            'requirements/base.txt',
            'requirements/production.txt'
        ]
        
        for req_file in requirements_files:
            req_path = os.path.join(self.project_root, req_file)
            if os.path.exists(req_path):
                self._scan_requirements_file(req_path)
        
        # Check for package.json (if Node.js is used)
        package_json_path = os.path.join(self.project_root, 'package.json')
        if os.path.exists(package_json_path):
            self._scan_package_json(package_json_path)
        
        print("‚úÖ Dependency scan completed.")
    
    def _scan_requirements_file(self, req_file_path: str):
        """Scan Python requirements file for vulnerable dependencies"""
        try:
            with open(req_file_path, 'r') as f:
                requirements = f.readlines()
            
            # Known vulnerable package patterns
            vulnerable_patterns = {
                'django<2.2.28': {
                    'severity': 'critical',
                    'description': 'Django version with known security vulnerabilities',
                    'cve': 'Multiple CVEs'
                },
                'pillow<8.3.2': {
                    'severity': 'high',
                    'description': 'Pillow version with image processing vulnerabilities',
                    'cve': 'CVE-2021-34552'
                },
                'requests<2.20.0': {
                    'severity': 'medium',
                    'description': 'Requests library with SSL verification issues',
                    'cve': 'CVE-2018-18074'
                },
                'pyyaml<5.4': {
                    'severity': 'high',
                    'description': 'PyYAML with unsafe loading vulnerabilities',
                    'cve': 'CVE-2020-14343'
                }
            }
            
            for line_num, line in enumerate(requirements, 1):
                line = line.strip().lower()
                if line and not line.startswith('#'):
                    for pattern, vuln_info in vulnerable_patterns.items():
                        if self._matches_vulnerable_pattern(line, pattern):
                            vuln_id = self._generate_vulnerability_id(req_file_path, line_num, 'dependency')
                            
                            vulnerability = Vulnerability(
                                id=vuln_id,
                                severity=vuln_info['severity'],
                                category='dependency',
                                title=f'Vulnerable Dependency: {pattern.split("<")[0]}',
                                description=vuln_info['description'],
                                file_path=os.path.relpath(req_file_path, self.project_root),
                                line_number=line_num,
                                code_snippet=line,
                                recommendation=f'Update {pattern.split("<")[0]} to latest secure version',
                                references=[vuln_info.get('cve', '')]
                            )
                            
                            self.vulnerabilities.append(vulnerability)
        
        except Exception as e:
            print(f"‚ö†Ô∏è  Error scanning requirements file {req_file_path}: {e}")
    
    def _matches_vulnerable_pattern(self, dependency_line: str, pattern: str) -> bool:
        """Check if dependency line matches vulnerable pattern"""
        package_name = pattern.split('<')[0].split('==')[0].split('>=')[0]
        return package_name in dependency_line and '<' not in dependency_line
    
    def _scan_package_json(self, package_json_path: str):
        """Scan Node.js package.json for vulnerable dependencies"""
        try:
            with open(package_json_path, 'r') as f:
                package_data = json.load(f)
            
            dependencies = package_data.get('dependencies', {})
            dev_dependencies = package_data.get('devDependencies', {})
            all_deps = {**dependencies, **dev_dependencies}
            
            # Known vulnerable Node.js packages
            vulnerable_js_packages = {
                'lodash': {
                    'versions': ['<4.17.19'],
                    'severity': 'high',
                    'description': 'Lodash prototype pollution vulnerability'
                },
                'express': {
                    'versions': ['<4.17.1'],
                    'severity': 'medium',
                    'description': 'Express.js with security vulnerabilities'
                }
            }
            
            for dep_name, dep_version in all_deps.items():
                if dep_name in vulnerable_js_packages:
                    vuln_info = vulnerable_js_packages[dep_name]
                    
                    vuln_id = self._generate_vulnerability_id(package_json_path, 0, f'js_dependency_{dep_name}')
                    
                    vulnerability = Vulnerability(
                        id=vuln_id,
                        severity=vuln_info['severity'],
                        category='dependency',
                        title=f'Vulnerable Node.js Dependency: {dep_name}',
                        description=vuln_info['description'],
                        file_path=os.path.relpath(package_json_path, self.project_root),
                        line_number=0,
                        code_snippet=f'"{dep_name}": "{dep_version}"',
                        recommendation=f'Update {dep_name} to latest secure version'
                    )
                    
                    self.vulnerabilities.append(vulnerability)
        
        except Exception as e:
            print(f"‚ö†Ô∏è  Error scanning package.json: {e}")
    
    def _run_configuration_scan(self):
        """Scan configuration files for security issues"""
        print("‚öôÔ∏è  Running configuration security scan...")
        
        # Django settings files
        settings_patterns = ['**/settings.py', '**/settings/*.py']
        
        for root, dirs, files in os.walk(self.project_root):
            dirs[:] = [d for d in dirs if d not in self.exclude_dirs]
            
            for file in files:
                if file == 'settings.py' or file.endswith('_settings.py'):
                    file_path = os.path.join(root, file)
                    self._scan_django_settings(file_path)
        
        print("‚úÖ Configuration scan completed.")
    
    def _scan_django_settings(self, settings_path: str):
        """Scan Django settings for security misconfigurations"""
        try:
            with open(settings_path, 'r') as f:
                content = f.read()
            
            lines = content.split('\n')
            
            # Security configuration checks
            config_checks = {
                'debug_enabled': {
                    'pattern': r'DEBUG\s*=\s*True',
                    'severity': 'high',
                    'description': 'Debug mode enabled in production'
                },
                'empty_allowed_hosts': {
                    'pattern': r'ALLOWED_HOSTS\s*=\s*\[\s*\]',
                    'severity': 'medium',
                    'description': 'Empty ALLOWED_HOSTS configuration'
                },
                'weak_secret_key': {
                    'pattern': r'SECRET_KEY\s*=\s*["\'][^"\']{1,20}["\']',
                    'severity': 'high',
                    'description': 'Weak or short SECRET_KEY'
                },
                'missing_csrf_middleware': {
                    'pattern': r'django\.middleware\.csrf\.CsrfViewMiddleware',
                    'severity': 'medium',
                    'description': 'CSRF middleware check'
                }
            }
            
            for line_num, line in enumerate(lines, 1):
                for check_name, check_info in config_checks.items():
                    match = re.search(check_info['pattern'], line)
                    if match:
                        # Special handling for missing CSRF middleware
                        if check_name == 'missing_csrf_middleware':
                            continue  # Found CSRF middleware - this is good
                        
                        vuln_id = self._generate_vulnerability_id(settings_path, line_num, check_name)
                        
                        vulnerability = Vulnerability(
                            id=vuln_id,
                            severity=check_info['severity'],
                            category='configuration',
                            title=f'Security Misconfiguration: {check_name.replace("_", " ").title()}',
                            description=check_info['description'],
                            file_path=os.path.relpath(settings_path, self.project_root),
                            line_number=line_num,
                            code_snippet=line.strip(),
                            recommendation=self._get_config_recommendation(check_name)
                        )
                        
                        self.vulnerabilities.append(vulnerability)
        
        except Exception as e:
            print(f"‚ö†Ô∏è  Error scanning Django settings {settings_path}: {e}")
    
    def _run_permission_scan(self):
        """Scan file permissions for security issues"""
        print("üîê Running file permission scan...")
        
        sensitive_files = [
            'settings.py', 'secret.key', '.env', 'private.key',
            'id_rsa', 'id_dsa', '.pem', '.key'
        ]
        
        for root, dirs, files in os.walk(self.project_root):
            dirs[:] = [d for d in dirs if d not in self.exclude_dirs]
            
            for file in files:
                file_path = os.path.join(root, file)
                
                # Check sensitive files
                if any(sensitive in file.lower() for sensitive in sensitive_files):
                    try:
                        file_stat = os.stat(file_path)
                        file_mode = oct(file_stat.st_mode)[-3:]
                        
                        # Check if file is world-readable (permissions ending in 4, 5, 6, or 7)
                        if file_mode[-1] in ['4', '5', '6', '7']:
                            vuln_id = self._generate_vulnerability_id(file_path, 0, 'world_readable')
                            
                            vulnerability = Vulnerability(
                                id=vuln_id,
                                severity='medium',
                                category='permissions',
                                title='World-Readable Sensitive File',
                                description=f'Sensitive file {file} is world-readable (permissions: {file_mode})',
                                file_path=os.path.relpath(file_path, self.project_root),
                                line_number=0,
                                code_snippet=f'File permissions: {file_mode}',
                                recommendation='Set restrictive permissions (600 or 644) for sensitive files'
                            )
                            
                            self.vulnerabilities.append(vulnerability)
                    
                    except Exception as e:
                        continue  # Skip files we can't stat
        
        print("‚úÖ File permission scan completed.")
    
    def _generate_vulnerability_id(self, file_path: str, line_number: int, vuln_type: str) -> str:
        """Generate unique vulnerability ID"""
        hash_input = f"{file_path}:{line_number}:{vuln_type}"
        return hashlib.md5(hash_input.encode()).hexdigest()[:16]
    
    def _get_vulnerability_title(self, pattern_name: str) -> str:
        """Get human-readable title for vulnerability pattern"""
        titles = {
            'sql_injection': 'SQL Injection Vulnerability',
            'xss': 'Cross-Site Scripting (XSS) Vulnerability',
            'csrf_missing': 'Missing CSRF Protection',
            'hardcoded_secrets': 'Hardcoded Secrets in Code',
            'weak_crypto': 'Weak Cryptographic Algorithm',
            'path_traversal': 'Path Traversal Vulnerability',
            'debug_enabled': 'Debug Mode Enabled',
            'unsafe_deserialization': 'Unsafe Deserialization'
        }
        return titles.get(pattern_name, f'Security Issue: {pattern_name}')
    
    def _get_vulnerability_description(self, pattern_name: str) -> str:
        """Get detailed description for vulnerability pattern"""
        descriptions = {
            'sql_injection': 'Code uses string formatting in SQL queries, potentially allowing SQL injection attacks',
            'xss': 'User input is rendered without proper escaping, potentially allowing XSS attacks',
            'csrf_missing': 'View function bypasses CSRF protection, allowing cross-site request forgery',
            'hardcoded_secrets': 'Sensitive credentials are hardcoded in source code',
            'weak_crypto': 'Code uses weak or deprecated cryptographic algorithms',
            'path_traversal': 'File operations use unsanitized user input, allowing path traversal attacks',
            'debug_enabled': 'Debug mode exposes sensitive information in production',
            'unsafe_deserialization': 'Code deserializes untrusted data without validation'
        }
        return descriptions.get(pattern_name, f'Security vulnerability detected: {pattern_name}')
    
    def _get_vulnerability_recommendation(self, pattern_name: str) -> str:
        """Get remediation recommendation for vulnerability pattern"""
        recommendations = {
            'sql_injection': 'Use parameterized queries or ORM methods instead of string formatting',
            'xss': 'Use proper output encoding and template auto-escaping',
            'csrf_missing': 'Remove @csrf_exempt decorator and implement proper CSRF protection',
            'hardcoded_secrets': 'Move secrets to environment variables or secure configuration files',
            'weak_crypto': 'Use strong cryptographic algorithms like SHA-256 or bcrypt',
            'path_traversal': 'Validate and sanitize file paths, use os.path.abspath() and check boundaries',
            'debug_enabled': 'Set DEBUG=False in production settings',
            'unsafe_deserialization': 'Validate input before deserialization or use safer formats like JSON'
        }
        return recommendations.get(pattern_name, 'Review and fix security issue')
    
    def _get_config_recommendation(self, config_name: str) -> str:
        """Get configuration-specific recommendations"""
        recommendations = {
            'debug_enabled': 'Set DEBUG = False in production environment',
            'empty_allowed_hosts': 'Configure ALLOWED_HOSTS with specific domain names',
            'weak_secret_key': 'Generate a strong, random SECRET_KEY of at least 50 characters',
            'missing_csrf_middleware': 'Add CsrfViewMiddleware to MIDDLEWARE setting'
        }
        return recommendations.get(config_name, 'Fix configuration security issue')
    
    def _assess_confidence(self, pattern_name: str, code_line: str) -> str:
        """Assess confidence level of vulnerability detection"""
        # High confidence patterns
        high_confidence = ['sql_injection', 'xss', 'hardcoded_secrets']
        
        # Low confidence patterns that might have false positives
        low_confidence = ['debug_enabled', 'weak_crypto']
        
        if pattern_name in high_confidence:
            return 'high'
        elif pattern_name in low_confidence:
            return 'low'
        else:
            return 'medium'
    
    def _generate_scan_report(self) -> Dict[str, Any]:
        """Generate comprehensive vulnerability scan report"""
        
        # Categorize vulnerabilities
        vulns_by_severity = {}
        vulns_by_category = {}
        
        for vuln in self.vulnerabilities:
            # By severity
            if vuln.severity not in vulns_by_severity:
                vulns_by_severity[vuln.severity] = []
            vulns_by_severity[vuln.severity].append(vuln)
            
            # By category
            if vuln.category not in vulns_by_category:
                vulns_by_category[vuln.category] = []
            vulns_by_category[vuln.category].append(vuln)
        
        # Calculate risk score
        risk_score = self._calculate_risk_score()
        
        report = {
            'scan_metadata': {
                'scan_date': datetime.now().isoformat(),
                'project_root': self.project_root,
                'scanner_version': '1.0.0',
                'total_vulnerabilities': len(self.vulnerabilities)
            },
            'summary': {
                'total_vulnerabilities': len(self.vulnerabilities),
                'risk_score': risk_score,
                'risk_level': self._assess_risk_level(risk_score),
                'vulnerabilities_by_severity': {
                    severity: len(vulns) for severity, vulns in vulns_by_severity.items()
                },
                'vulnerabilities_by_category': {
                    category: len(vulns) for category, vulns in vulns_by_category.items()
                }
            },
            'vulnerabilities': [asdict(vuln) for vuln in self.vulnerabilities],
            'recommendations': self._generate_remediation_recommendations()
        }
        
        # Print scan summary
        self._print_scan_summary(report)
        
        # Save report
        self._save_scan_report(report)
        
        return report
    
    def _calculate_risk_score(self) -> float:
        """Calculate overall risk score (0-100)"""
        if not self.vulnerabilities:
            return 0.0
        
        severity_weights = {
            'critical': 10,
            'high': 7,
            'medium': 4,
            'low': 2,
            'info': 1
        }
        
        total_score = sum(severity_weights.get(vuln.severity, 1) for vuln in self.vulnerabilities)
        max_possible_score = len(self.vulnerabilities) * 10  # All critical
        
        return round((total_score / max_possible_score) * 100, 2) if max_possible_score > 0 else 0.0
    
    def _assess_risk_level(self, risk_score: float) -> str:
        """Assess risk level based on score"""
        if risk_score >= 80:
            return 'CRITICAL'
        elif risk_score >= 60:
            return 'HIGH'
        elif risk_score >= 40:
            return 'MEDIUM'
        elif risk_score >= 20:
            return 'LOW'
        else:
            return 'MINIMAL'
    
    def _generate_remediation_recommendations(self) -> List[Dict[str, Any]]:
        """Generate prioritized remediation recommendations"""
        recommendations = []
        
        # Group by category and severity
        critical_vulns = [v for v in self.vulnerabilities if v.severity == 'critical']
        high_vulns = [v for v in self.vulnerabilities if v.severity == 'high']
        
        if critical_vulns:
            recommendations.append({
                'priority': 'immediate',
                'category': 'critical_vulnerabilities',
                'title': 'Address Critical Vulnerabilities',
                'description': f'Fix {len(critical_vulns)} critical security vulnerabilities immediately',
                'actions': list(set(v.recommendation for v in critical_vulns))
            })
        
        if high_vulns:
            recommendations.append({
                'priority': 'high',
                'category': 'high_vulnerabilities', 
                'title': 'Address High-Severity Vulnerabilities',
                'description': f'Fix {len(high_vulns)} high-severity security vulnerabilities',
                'actions': list(set(v.recommendation for v in high_vulns))
            })
        
        return recommendations
    
    def _print_scan_summary(self, report: Dict[str, Any]):
        """Print vulnerability scan summary"""
        print("\n" + "=" * 60)
        print("üîç VULNERABILITY SCAN SUMMARY")
        print("=" * 60)
        
        summary = report['summary']
        print(f"Total Vulnerabilities: {summary['total_vulnerabilities']}")
        print(f"Risk Score: {summary['risk_score']}/100")
        print(f"Risk Level: {summary['risk_level']}")
        
        print("\nüìä Vulnerabilities by Severity:")
        for severity, count in summary['vulnerabilities_by_severity'].items():
            emoji = {'critical': 'üî¥', 'high': 'üü†', 'medium': 'üü°', 'low': 'üü¢', 'info': 'üîµ'}.get(severity, '‚ö™')
            print(f"  {emoji} {severity.title()}: {count}")
        
        print("\nüìÇ Vulnerabilities by Category:")
        for category, count in summary['vulnerabilities_by_category'].items():
            print(f"  ‚Ä¢ {category.replace('_', ' ').title()}: {count}")
        
        if report.get('recommendations'):
            print(f"\nüìã Priority Actions:")
            for rec in report['recommendations'][:3]:
                print(f"  ‚Ä¢ {rec['title']}: {rec['description']}")
    
    def _save_scan_report(self, report: Dict[str, Any]):
        """Save vulnerability scan report to file"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"vulnerability_scan_report_{timestamp}.json"
        filepath = os.path.join(os.path.dirname(__file__), filename)
        
        try:
            with open(filepath, 'w') as f:
                json.dump(report, f, indent=2, default=str)
            print(f"\nüíæ Vulnerability scan report saved to: {filepath}")
        except Exception as e:
            print(f"‚ö†Ô∏è  Could not save scan report: {e}")


def scan_project(project_root: str = None) -> Dict[str, Any]:
    """Main function to run vulnerability scan"""
    if project_root is None:
        project_root = os.path.dirname(os.path.dirname(os.path.dirname(__file__)))
    
    scanner = VulnerabilityScanner(project_root)
    return scanner.run_comprehensive_scan()


if __name__ == "__main__":
    import sys
    
    project_path = sys.argv[1] if len(sys.argv) > 1 else None
    report = scan_project(project_path)
    
    # Exit with appropriate code based on risk level
    risk_level = report['summary']['risk_level']
    if risk_level in ['CRITICAL', 'HIGH']:
        sys.exit(1)
    else:
        sys.exit(0)
